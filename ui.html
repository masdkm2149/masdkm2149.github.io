<!DOCTYPE html>
<html>
<head>
  <style>
    /* --- Existing styles --- */
    :root {
      --color-primary: #0078ce; /* Figma blue */
      --color-primary-darkened: #275F88; /* Darker blue */
      --color-secondary: #383838; /* Dark gray */
      --color-form-background: #2C2C2C; /* Border color */
      --color-background: #1E1E1E; /* Slightly less dark gray */
      --color-icons-lighter: #e9e9e9; /* Dark gray */
      --color-icons: #dddddd; /* Darker gray */
       --color-icons-darker: #bbbbbb; /* Light gray for icons */
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-size: 11.3px;
      padding: 8px;
      margin: 0;
      background: var(--color-background); /* Figma's dark background */
      color: #FFFFFF; /* White text */
    }
    .container {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .section {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .label {
      font-weight: 500;
      font-size: 11.3px;
      color: var(--color-icons);
      margin-bottom: 4px;
    }
    /* Style for draggable weight label (visual cue) */
    .label#stroke-weight-label {
        user-select: none; /* Prevent text selection */
    }

    .input-row {
      display: flex;
      align-items: top;
      gap: 8px;
    }

    .input-row.color-selection {
      left:0;
      align-items: center;
      gap: 0;
      position: relative;
    }
    /* Base styles for number and text inputs */
    input[type="number"], input[type="text"] {
      padding: 4px;
      border: 1px solid var(--color-secondary); /* Darker border */
      font-size: 11.3px;
      background: var(--color-form-background); /* Dark input background */
      color: var(--color-icons);
      border-radius: 5px; /* Moved border-radius here */
    }
    /* Default width for number inputs */
    input[type="number"] {
        width: 3.5rem;
    }
    input[type="text"]#current-stop-color {
      margin-left: 8px;
      text-indent: -7px;
      margin-inline-end: 3px;
      padding-left: 23px;
      width: 96%;
    }

    /* Default width for text inputs (like hex color) */
    input[type="number"]#stroke-weight {
      width: 4.5rem;
      padding: 5px;
      text-indent: 19px;
      user-select: none; /* Keep: Prevent text selection during drag */
    }
    /* *** ADDED: Specific style for the position text input *** */
    input[type="text"]#current-stop-position {
        width: 3rem; /* Match original number input width */
        font-size: 11.3px;
        padding-inline: 0.5rem;
        color: var(--color-icons);
    }
    ::selection {
      background-color: var(--color-primary-darkened);
    }
    /* Input focus styles */
    input[type="number"]#current-stop-alpha:focus, input[type="number"]#current-stop-alpha {
      box-shadow: none;
      border: none;
    }

    input#current-stop-position:focus, button:focus, .custom-select:has(.select-hide) .select-selected:focus:not(:active), .highlight, input#current-stop-color:focus, input[type="number"]:focus, select:focus { /* Updated focus selector for custom select */
      outline: none;
      box-shadow: 0 0 0 2px var(--color-primary); /* Blue outline on focus */
    }
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
    }
     /* Style only the remaining standard select */
    /* select#stroke-join removed */

    .gradient-container {
      position: relative;
      height: 3rem;
      width: 90%;
      margin: 1rem auto 0.5rem auto;
    }
    .gradient-bar {
      height: 2rem;
      z-index: 5;
      width: 100%;
      background: linear-gradient(to right, #ff0000, #0000ff);
      border: 1.5px solid var(--color-secondary);
      border-radius: .33rem;
      position: absolute;
      top: 1rem;
      cursor: pointer; /* Add cursor pointer to indicate clickable area */
    }
    .color-stops {
      position: relative;
      width: 100%;
      height: 100%;
    }
    .color-stop {
      position: absolute;
      transform: translate(-50%, -9px);
      z-index: 10;
    }
    .color-preview {
      width: 16px;
      height: 16px;
      border: 5px solid var(--color-secondary);
      border-radius: 20%;
      cursor:pointer;
      position: relative;
    }
    .selected .color-preview {
      cursor:grab; /* Change cursor to indicate selected state */
      border-color: var(--color-primary); /* Highlight selected stop */
    }
    .color-preview:active {
      cursor: grabbing;
    }
    .color-preview::after {
      content: "";
      box-sizing: border-box;
      border: 6px solid transparent;
      border-top-color: var(--color-secondary);
      position: absolute;
      top: calc(100% + 5px);
      left: 50%;
      transform: translate(-50%);
    }
    .selected .color-preview::after {
      border-top-color: var(--color-primary); /* Highlight selected stop arrow */
    }
    input[type="color"] {
      width: 0;
      height: 0;
      opacity: 0;
      margin-left: 20px;
      position: absolute;
    }
    button {
      background: var(--color-secondary);
      color: var(--color-icons);
      border: none;
      border-radius: 6px;
      font-size: 11.5px;
      cursor: pointer;
      width: fit-content;
      padding: 0.5rem 2rem;
      margin: auto;
      text-align: center;
    }

    /* Original styles for the stops editor panel */
    .stops-panel {
      margin: 0;
      padding: 0.65rem;
    }
    .stops-panel-header {
      display: flex;
      flex-direction: row;
      margin-left: 1.5px;
      margin-bottom: .5rem;
      justify-content: space-between;
    }
    button#add-stop-btn, button#remove-stop-btn {
      padding: 2px 6px;
      background: none;
      font-size: 18px;
    }
    button:hover {
      background-color: var(--color-form-background);
    }
    button#add-stop-btn:active, button#add-stop-btn:active:focus, button#add-stop-btn:active:hover, button#remove-stop-btn:active, button#remove-stop-btn:active:focus, button#remove-stop-btn:active:hover {
      background-color: var(--color-secondary);
    }
    .stop-editor {
      display: flex;
      align-items: center;
      margin: 0.25rem 0;
    }
    * {
         font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
         font-weight: 500;
    }
    .section.stroke-properties {
      margin: 0;
    }
    /* Original '+' button styles */
    button#add-stop-btn {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      font-size: 1.5rem;
      margin-top:-0.2rem;
      padding: 0;
      color: var(--color-icons-darker);
      font-weight: 300;
      position: absolute;
      right: .93rem;
      height: 0px;
      line-height: 0;
      padding: 8px 3px 14px 3px;
    }
    button#remove-stop-btn {
      background: none;
      padding: 0;
      display: flex;
      left: .7rem;
      font-size: 14px;
      height: 1.4rem;
      padding:0px 6px 0px 6px;
      font-weight: 400;
      position: relative;
    }
    button#add-stop-btn:hover, button#remove-stop-btn:hover, .settings:hover {
        background-color: var(--color-form-background); /* Match other buttons */
     }
     #line-break-vertical {
        width: 1px;
            transform: translateX(-8px);
        height: 23px;
        position: relative;
        background-color: var(--color-background);
        margin-left: -3.1rem; /* Adjusted for spacing */
     }
    .current-stop-preview {
      width: 12px;
      height: 12px;
      border: 1px solid var(--color-secondary);
      border-radius: 3px;
      position: absolute;
      margin-left: 13.4px;
      cursor: pointer;
    }
    label[for="current-stop-alpha"] {
    text-indent: -3;
    color: var(--color-icons);
    }
      input[type="number"]#current-stop-alpha {
        width: 2rem;
        text-align: right;
    }
    .input-column {
      gap:0.2rem; /* space between label and inputs/forms */
      display: flex;
      flex-direction: column;
      min-width: 0; /* Prevent overflow issues */
    }
    .section.top-controls {
      padding: 0.4rem .8rem;
    }
    /*.input-row:not(:has(.label[for="stroke-weight"])) {
      margin-top: .5rem;
      margin-bottom: .2rem;
    }*/
    input#stroke-weight {}
    .label[for="start-cap-value"], .label[for="end-cap-value"], .label#stroke-weight-label, .label[for="stroke-join-value"] { /* Updated selector for weight/join label */
      color: var(--color-icons-darker);
      font-size: 10.8px;
      font-weight: 600;
    }

/* --- CSS Modifications (Targeted) --- */

/* Keep options always visible ONLY for the join selector */
.custom-select-wrapper.join-options-visible .select-items {
    /* Change from absolute positioning */
    position: static;
    /* Remove dropdown-specific styles */
    border: none;
    display: flex;
    flex-direction: row;
    gap: 4px;
    border-radius: 5px;
    background-color: var(--color-form-background);
    padding: 2px 0;
    /* Remove height/overflow constraints */
    max-height: none;
    overflow-y: visible;
    padding-inline-start: 2px;
    padding-inline-end: 2px;
    align-items: center;
}
.custom-select-wrapper.join-options-visible{
    width: min-content;
}
/* Style the selected item ONLY for join selector */
.custom-select-wrapper.join-options-visible .select-option.same-as-selected {
     background-color: var(--color-background);
     border-color: var(--color-primary);
}

/* Hide the original trigger box ONLY for join selector */
.custom-select-wrapper.join-options-visible .select-selected {
    display: none;
}


    /* --- Custom Select Styles --- */
    .custom-select-wrapper {
        position: relative;
        min-width: 5.6rem;
        font-size: 11.3px;
        color: var(--color-icons-lighter);
    }
    .custom-select .select-selected {
        background-color: var(--color-background);
        padding: 5px 20px 5px 5px; /* Make space for arrow */
        border: 1px solid var(--color-secondary);
        border-radius: 3px;
        cursor: pointer;
        display: flex; /* Use flex for icon alignment */
        padding-inline: 10.5px;
        align-items: center; /* Center items vertically */
        gap: 6px; /* Space between icon and text */
        position: relative; /* For arrow positioning */
        min-height: 21.6px; /* Match input height */
        outline: none;
        box-sizing: border-box;
        width: 100%; /* Make selected box take full wrapper width */
    }
    .custom-select .select-selected::after { /* Dropdown arrow */
        content: "";
        position: absolute;
        right: 6px;
        top: 50%;
        transform: translateY(-28%);
        width: 0;
        height: 0;
        border-left: 4px solid transparent;
        border-right: 4px solid transparent;
        border-top: 4px solid var(--color-icons); /* Arrow color */
    }
    .custom-select .select-selected.select-arrow-active::after { /* Arrow when open */
        border-top: none;
        border-bottom: 4px solid var(--color-icons);
    }
    .custom-select .select-items {
        position: absolute;
        background-color: var(--color-background);
        top: 0;
        left: 0;
        right: 0;
        z-index: 99;
        border: 1px solid var(--color-secondary);
        border-radius:3px;
        max-height: 150px; /* Optional: scroll for long lists */
        overflow-y: auto;
        box-sizing: border-box;
    }
    .custom-select .select-hide {
        display: none;
    }
    .custom-select .select-option {
        color: var(--color-icons-lighter);
        padding: 5px 8px;
        padding-inline: .66rem;
        cursor: pointer;
        display: flex; /* Use flex for icon alignment */
        align-items: center; /* Center items vertically */
        gap: 6px; /* Space between icon and text */
    }
    /* Adjust icon size within options */
    .custom-select .select-option svg {
        width: 14px; /* Keep consistent */
        height: 14px; /* Make square */
        fill: none; /* Use stroke for join icons */
        stroke: currentColor; /* Inherit text color for stroke */
        stroke-width: 1.5; /* Adjust stroke width as needed */
        flex-shrink: 0; /* Prevent icon shrinking */
        margin-top: .8px;
    }
    /* Specific icon size for selected display */
    .custom-select .select-selected svg {
        width: 14px;
        height: 14px;
        fill: none;
        stroke: currentColor;
        stroke-width: 1.5;
        flex-shrink: 0;
        margin-top: .8px;
    }
    /* Cap icons use fill, not stroke */
     .custom-select .select-option svg.cap-icon,
     .custom-select .select-selected svg.cap-icon {
        fill: currentColor;
        stroke: none;
        height: 10px; /* Revert cap icons to original height */
     }
     /* Arrow Cap icons use stroke */
     .custom-select .select-option svg.arrow-cap-icon,
     .custom-select .select-selected svg.arrow-cap-icon {
        fill: none;
        stroke: currentColor;
        stroke-width: 1.5;
        stroke-linecap: round;
        stroke-linejoin: round;
        height: 10px;
     }
     .custom-select .same-as-selected {
        background-color: var(--color-primary-darkened);
        /* border-bottom: 1px solid var(--color-secondary); */ /* Removed border */
    }
    .custom-select:not(.same-as-selected) .select-option:not(.same-as-selected):active, .custom-select:not(.same-as-selected) .select-option:not(.same-as-selected):focus {background-color: var(--color-secondary); }
    .custom-select:not(.same-as-selected) .select-option:not(.same-as-selected):hover:not(:active):not(:focus) {background-color: var(--color-form-background); }
    /* Hide the actual input used for storing the value */
    .custom-select-wrapper input[type="hidden"] {
        display: none;
    }
    .weight-icon{
      position: absolute;
      margin-top: 25px;
      margin-left: 1px;
      pointer-events: none; /* Make icon non-interactive */
    }


/* --- Custom Tooltip Styles --- */
.select-option svg {z-index: 1;}
/* Make the container relative for absolute positioning of the tooltip */
.custom-select-wrapper.join-options-visible .select-option {
    position: relative; /* Needed for tooltip positioning */
    padding: .3rem .55rem;
    border-radius: 3px;
}

.custom-tooltip {
  visibility: hidden; /* Hidden by default */
  opacity: 0; /* Fade effect */
  transition: opacity 0.2s ease-in-out; /* Smooth fade */
  position: absolute;
  bottom: 100%; /* Position above the element */
  left: 50%;
  transform: translateX(-50%); /* Center horizontally */
  background-color: var(--color-background); /* Use your theme colors */
  color: var(--color-icons-lighter);
  border:1px solid var(--color-secondary);
  text-align: center;
  padding: 3px 6px;
  border-radius: 4px;
  font-size: 10px; /* Adjust as needed */
  white-space: nowrap; /* Prevent wrapping */
}

/* Show the tooltip on hover */
.custom-select-wrapper.join-options-visible .select-option:hover .custom-tooltip {
  visibility: visible;
  opacity: 1;
}
/* Outer border/arrow */
.custom-tooltip::before {
  content: "";
  position: absolute;
  top: 100%; /* Position below the tooltip body */
  left: 50%;
  transform: translateX(-50%); /* Center horizontally */
  border-width: 7.25px; /* Slightly larger than ::after */
  border-style: solid;
  /* Outer border color (e.g., white) on top, rest transparent */
  border-color: var(--color-secondary) transparent transparent transparent;
}
/* Inner border/arrow */
.custom-tooltip::after {
    content: "";
    position: absolute;
    top: 100%;
    left: 50%;
    margin-left: -6px;
    border-width: 6px;
    border-style: solid;
    border-color: var(--color-background) transparent transparent transparent;
  }
 .stop-editor {
    /*background-color: var(--color-primary-darkened);
    border-color: var(--color-primary);*/
    padding: 3px;
    outline: none;
    cursor: pointer;
    border-radius: 5px;
    border: 1px solid transparent;
  }
  div[data-value="ARROW_LINES"] {
  }
div#end-stop {
    margin-left: -2px;
}

.settings {
    height: 20px;
    padding: 4px;
    border-radius: 6px;
    position: fixed;
    color: var(--color-icons-darker);
    right: 16px;
}
.select-selected span {
width: 50px;
}
.select-items span {
  width: min-content;
}
.custom-tooltip, .custom-tooltip::after, .custom-tooltip::before {overflow: visible!important;}
.select-items span, .select-selected span {
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
}
.custom-select-wrapper:has(input#start-cap-value) .custom-select, .custom-select-wrapper:has(input#end-cap-value) .custom-select {
  min-width: 6.5rem;
}


  </style>
</head>
<body>
  <div class="container">
    <div class="section stroke-properties">
      <div class="section top-controls">
        <div class="input-row">
          <div class="input-column">
            <div class="label" for="stroke-weight" id="stroke-weight-label">Weight</div>
            <svg class="weight-icon" width="24" height="24" fill="none" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M6 6.5a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5M7 10v1h10v-1zm-.25-1a.75.75 0 0 0-.75.75v1.5c0 .414.336.75.75.75h10.5a.75.75 0 0 0 .75-.75v-1.5a.75.75 0 0 0-.75-.75zM7 17v-2h10v2zm-1-2.25a.75.75 0 0 1 .75-.75h10.5a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-.75.75H6.75a.75.75 0 0 1-.75-.75z" clip-rule="evenodd" fill="var(--color-icons-darker)"></path></svg>
            <input type="number" id="stroke-weight" value="1" min="0" step="any" draggable="false">
          </div>
          <div class="input-column">      
            <div class="label" for="stroke-join-value">Join</div>
            <div class="input-row">
            <div class="custom-select-wrapper join-options-visible">
              <input type="hidden" id="stroke-join-value" value="ROUND">
              <div class="custom-select">
                 <div class="select-selected" tabindex="0" id="stroke-join-select">
                   </div>
                 <div class="select-items">
                   <div class="select-option" data-value="ROUND">
                    <span class="custom-tooltip">Round</span>
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <circle cx="9.2" cy="9.1" r="0.1" fill="currentColor"/>
                      <circle cx="8.5" cy="12.5" r="0.1" fill="currentColor"/>
                      <circle cx="12.7" cy="9" r="0.1" fill="currentColor"/>
                      <circle cx="14" cy="14" r="12" stroke="currentColor" stroke-width="1.8"/>
                      </svg>
                   </div>
                   <div class="select-option" data-value="MITER">
                    <span class="custom-tooltip">Miter</span>
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <circle cx="8.5" cy="8.5" r="0.1" fill="currentColor"/>
                      <circle cx="8.5" cy="12.5" r="0.1" fill="currentColor"/>
                      <circle cx="12.5" cy="8.5" r="0.1" fill="currentColor"/>
                      <path d="M1 13V1H13" stroke="currentColor" stroke-width="1.8" stroke-linecap="square"/>
                      </svg>
                   </div>
                   <div class="select-option" data-value="BEVEL">
                    <span class="custom-tooltip">Bevel</span>
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <circle cx="8.5" cy="8.5" r="0.1" fill="currentColor"/>
                      <circle cx="12.5" cy="7.5" r="0.1" fill="currentColor"/>
                      <circle cx="7.5" cy="12.5" r="0.1" fill="currentColor"/>
                      <path d="M13 1H7.24L1 8.2V13" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/>
                      </svg>
                   </div>
                 </div>
              </div>
            </div>
                          
            <div class="settings">
              <svg width="20" height="20" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M7.5 8.75C8.4665 8.75 9.25 7.9665 9.25 7C9.25 6.0335 8.4665 5.25 7.5 5.25C6.5335 5.25 5.75 6.0335 5.75 7C5.75 7.9665 6.5335 8.75 7.5 8.75Z" stroke="currentColor" stroke-width="1"/>
                <path d="M8.52961 1.2558C8.31518 1.16699 8.0434 1.16699 7.49979 1.16699C6.95619 1.16699 6.68441 1.16699 6.46998 1.2558C6.18413 1.37421 5.95701 1.60133 5.8386 1.88719C5.78454 2.01769 5.76339 2.16945 5.75511 2.39082C5.74295 2.71614 5.57611 3.01726 5.29418 3.18003C5.01225 3.3428 4.66806 3.33672 4.38024 3.1846C4.18439 3.08108 4.04238 3.02352 3.90234 3.00509C3.59557 2.9647 3.28532 3.04783 3.03984 3.23619C2.85573 3.37746 2.71983 3.61285 2.44803 4.08362C2.17623 4.55439 2.04033 4.78977 2.01004 5.01986C1.96966 5.32663 2.05279 5.63688 2.24115 5.88237C2.32712 5.99443 2.44795 6.08858 2.63549 6.20641C2.91118 6.37966 3.08856 6.67477 3.08855 7.00033C3.08853 7.32588 2.91115 7.62093 2.63548 7.79413C2.44792 7.91202 2.32707 8.00623 2.24109 8.11828C2.05273 8.36375 1.9696 8.67397 2.00999 8.98074C2.04027 9.21081 2.17617 9.44624 2.44797 9.91699C2.71977 10.3877 2.85567 10.6232 3.03978 10.7644C3.28526 10.9528 3.59551 11.0359 3.90228 10.9955C4.04231 10.9771 4.18431 10.9195 4.38015 10.816C4.66799 10.6639 5.0122 10.6578 5.29415 10.8206C5.5761 10.9834 5.74295 11.2845 5.75511 11.6099C5.76339 11.8312 5.78454 11.983 5.8386 12.1135C5.95701 12.3993 6.18413 12.6265 6.46998 12.7449C6.68441 12.8337 6.95619 12.8337 7.49979 12.8337C8.0434 12.8337 8.31518 12.8337 8.52961 12.7449C8.81544 12.6265 9.04259 12.3993 9.16095 12.1135C9.21503 11.983 9.2362 11.8312 9.24449 11.6098C9.25662 11.2845 9.42345 10.9834 9.70538 10.8206C9.9873 10.6578 10.3315 10.6639 10.6194 10.816C10.8152 10.9195 10.9572 10.977 11.0972 10.9955C11.404 11.0359 11.7143 10.9528 11.9597 10.7644C12.1438 10.6231 12.2797 10.3877 12.5515 9.91693C12.8234 9.44618 12.9593 9.21081 12.9895 8.98074C13.0299 8.67397 12.9468 8.36369 12.7584 8.11823C12.6724 8.00617 12.5516 7.91196 12.364 7.79413C12.0884 7.62093 11.911 7.32583 11.911 7.00027C11.911 6.67471 12.0884 6.37972 12.364 6.20653C12.5516 6.08863 12.6725 5.99448 12.7585 5.88237C12.9468 5.63692 13.03 5.32667 12.9896 5.01989C12.9593 4.78981 12.8234 4.55443 12.5516 4.08366C12.2798 3.61289 12.1439 3.3775 11.9598 3.23623C11.7143 3.04787 11.404 2.96474 11.0973 3.00513C10.9573 3.02356 10.8153 3.08112 10.6194 3.18463C10.3316 3.33675 9.98736 3.34284 9.70544 3.18005C9.42345 3.01727 9.25662 2.71613 9.24449 2.39079C9.2362 2.16944 9.21503 2.01768 9.16095 1.88719C9.04259 1.60133 8.81544 1.37421 8.52961 1.2558Z" stroke="currentColor" stroke-width="1.25"/>
                </svg></div>

            </div> 
          </div>
        </div>

        <div class="input-row">
          <div class="input-column">
            <div class="label" for="start-cap-value">Start point</div>
            <div class="custom-select-wrapper">
              <input type="hidden" id="start-cap-value" value="ROUND">
              <div class="custom-select">
                 <div class="select-selected" tabindex="0" id="start-cap-select">
                   </div>
                 <div class="select-items select-hide">
                   <div class="select-option" data-value="ROUND">
                     <svg class="cap-icon" width="14" height="10" viewBox="0 0 14 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 0.5C14 0.367392 13.9473 0.240215 13.8536 0.146447C13.7598 0.0526785 13.6326 0 13.5 0H5C3.67392 0 2.40215 0.526784 1.46447 1.46447C0.526784 2.40215 0 3.67392 0 5C0 6.32608 0.526784 7.59785 1.46447 8.53553C2.40215 9.47322 3.67392 10 5 10H13.5C13.6326 10 13.7598 9.94732 13.8536 9.85355C13.9473 9.75979 14 9.63261 14 9.5C14 9.36739 13.9473 9.24021 13.8536 9.14645C13.7598 9.05268 13.6326 9 13.5 9H5C3.93913 9 2.92172 8.57857 2.17157 7.82843C1.42143 7.07828 1 6.06087 1 5C1 3.93913 1.42143 2.92172 2.17157 2.17157C2.92172 1.42143 3.93913 1 5 1H13.5C13.6326 1 13.7598 0.947321 13.8536 0.853553C13.9473 0.759785 14 0.632608 14 0.5Z" fill="currentColor"/></svg>
                     <span>Round</span>
                   </div>
                   <div class="select-option" data-value="SQUARE">
                       <svg class="cap-icon" width="14" height="10" viewBox="0 0 14 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.5 10C13.6326 10 13.7598 9.94732 13.8536 9.85355C13.9473 9.75979 14 9.63261 14 9.5C14 9.36739 13.9473 9.24021 13.8536 9.14645C13.7598 9.05268 13.6326 9 13.5 9H1V1H13.5C13.6326 1 13.7598 0.947321 13.8536 0.853553C13.9473 0.759785 14 0.632608 14 0.5C14 0.367392 13.9473 0.240215 13.8536 0.146447C13.7598 0.0526785 13.6326 0 13.5 0H0.5C0.367392 0 0.240215 0.0526785 0.146447 0.146447C0.0526785 0.240215 0 0.367392 0 0.5V9.5C0 9.63261 0.0526785 9.75979 0.146447 9.85355C0.240215 9.94732 0.367392 10 0.5 10H13.5Z" fill="currentColor"/></svg>
                       <span>Square</span>
                   </div>
                   <div class="select-option" data-value="ARROW_LINES">
                       <svg class="arrow-cap-icon" style="transform: scaleX(-1)" width="14" height="10" viewBox="0 0 14 10" fill="none" xmlns="http://www.w3.org/2000/svg">
                         <path d="M1 5H10" stroke="currentColor"/>
                         <path d="M7 1.5L10.5 5L7 8.5" stroke="currentColor"/>
                       </svg>
                       <span>Line Arrow</span>
                   </div>
                   <div class="select-option" data-value="ARROW_EQUILATERAL">
                       <svg class="arrow-cap-icon" style="transform: scaleX(-1)" width="14" height="10" viewBox="0 0 14 10" fill="none" xmlns="http://www.w3.org/2000/svg">
                         <path d="M1 5H10" stroke="currentColor"/>
                         <path d="M7 1L11 5L7 9L7 1Z" stroke="currentColor" fill="currentColor"/>
                       </svg>
                       <span>Triangle Arrow</span>
                   </div>
               </div>
              </div>
            </div>
          </div>
          <div class="input-column">
            <div class="label" for="end-cap-value">End point</div>
            <div class="custom-select-wrapper">
               <input type="hidden" id="end-cap-value" value="ROUND">
               <div class="custom-select">
                  <div class="select-selected" tabindex="0" id="end-cap-select">
                    </div>
                  <div class="select-items select-hide">
                      <div class="select-option" data-value="ROUND">
                        <svg class="cap-icon" style="transform: scaleX(-1)" width="14" height="10" viewBox="0 0 14 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 0.5C14 0.367392 13.9473 0.240215 13.8536 0.146447C13.7598 0.0526785 13.6326 0 13.5 0H5C3.67392 0 2.40215 0.526784 1.46447 1.46447C0.526784 2.40215 0 3.67392 0 5C0 6.32608 0.526784 7.59785 1.46447 8.53553C2.40215 9.47322 3.67392 10 5 10H13.5C13.6326 10 13.7598 9.94732 13.8536 9.85355C13.9473 9.75979 14 9.63261 14 9.5C14 9.36739 13.9473 9.24021 13.8536 9.14645C13.7598 9.05268 13.6326 9 13.5 9H5C3.93913 9 2.92172 8.57857 2.17157 7.82843C1.42143 7.07828 1 6.06087 1 5C1 3.93913 1.42143 2.92172 2.17157 2.17157C2.92172 1.42143 3.93913 1 5 1H13.5C13.6326 1 13.7598 0.947321 13.8536 0.853553C13.9473 0.759785 14 0.632608 14 0.5Z" fill="currentColor"/></svg>
                        <span>Round</span>
                      </div>
                      <div class="select-option" data-value="SQUARE">
                          <svg class="cap-icon" style="transform: scaleX(-1)" width="14" height="10" viewBox="0 0 14 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.5 10C13.6326 10 13.7598 9.94732 13.8536 9.85355C13.9473 9.75979 14 9.63261 14 9.5C14 9.36739 13.9473 9.24021 13.8536 9.14645C13.7598 9.05268 13.6326 9 13.5 9H1V1H13.5C13.6326 1 13.7598 0.947321 13.8536 0.853553C13.9473 0.759785 14 0.632608 14 0.5C14 0.367392 13.9473 0.240215 13.8536 0.146447C13.7598 0.0526785 13.6326 0 13.5 0H0.5C0.367392 0 0.240215 0.0526785 0.146447 0.146447C0.0526785 0.240215 0 0.367392 0 0.5V9.5C0 9.63261 0.0526785 9.75979 0.146447 9.85355C0.240215 9.94732 0.367392 10 0.5 10H13.5Z" fill="currentColor"/></svg>
                          <span>Square</span>
                      </div>
                      <div class="select-option" data-value="ARROW_LINES">
                          <svg class="arrow-cap-icon" width="14" height="10" viewBox="0 0 14 10" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M1 5H10" stroke="currentColor"/>
                            <path d="M7 1.5L10.5 5L7 8.5" stroke="currentColor"/>
                          </svg>
                          <span>Line Arrow</span>
                      </div>
                      <div class="select-option" data-value="ARROW_EQUILATERAL">
                          <svg class="arrow-cap-icon" width="14" height="10" viewBox="0 0 14 10" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M1 5H10" stroke="currentColor"/>
                            <path d="M7 1L11 5L7 9L7 1Z" stroke="currentColor" fill="currentColor"/>
                          </svg>
                          <span>Triangle Arrow</span>
                      </div>
                  </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="section">
        <div class="gradient-container">
          <div class="gradient-bar" id="gradient-bar"></div>
          <div class="color-stops" id="color-stops">
            <div class="color-stop" id="start-stop" data-position="0" data-is-endpoint="true">
              <div class="color-preview" id="start-preview" style="background: #ff0000"></div>
              <input type="color" id="start-color" value="#ff0000">
            </div>
            <div class="color-stop" id="end-stop" data-position="100" data-is-endpoint="true">
              <div class="color-preview" id="end-preview" style="background: #0000ff"></div>
              <input type="color" id="end-color" value="#0000ff">
            </div>
            </div>
        </div>

        <div class="stops-panel">
          <div class="stops-panel-header">
            <div class="label">Stops</div>
            <button id="add-stop-btn">+</button>
          </div>
          <div class="stop-editor">
            <div class="input-row">
               <input type="text" id="current-stop-position" value="0%" min="0" max="100" step="1">
               </div>
            <div class="input-row color-selection">
              <div class="current-stop-preview" id="current-stop-color-preview"></div>
              <input type="text" id="current-stop-color" value="#ff0000">
              <div id="line-break-vertical"></div>
              <input type="number" id="current-stop-alpha" value="100" min="0" max="100" step="1">
              <label for="current-stop-alpha">%</label>
            </div>
            <button id="remove-stop-btn">—</button>
          </div>
        </div>
      </div>
      <button onclick="applyGradient()">Apply</button>
    </div>

    <script>
      // --- DOM Element References ---
      const startColorInput = document.getElementById('start-color');
      const endColorInput = document.getElementById('end-color');
      const startPreview = document.getElementById('start-preview');
      const endPreview = document.getElementById('end-preview');
      const gradientBar = document.getElementById('gradient-bar');
      const colorStops = document.getElementById('color-stops'); // Container for all stop elements
      const startStop = document.getElementById('start-stop');   // Start stop element
      const endStop = document.getElementById('end-stop');       // End stop element

      // Panel elements
      const currentStopPosition = document.getElementById('current-stop-position');
      const currentStopColor = document.getElementById('current-stop-color');
      const currentStopAlpha = document.getElementById('current-stop-alpha');
      const currentStopColorPreview = document.getElementById('current-stop-color-preview');
      const addStopBtn = document.getElementById('add-stop-btn');
      const removeStopBtn = document.getElementById('remove-stop-btn');

      // Stroke Weight Elements
      const strokeWeightInput = document.getElementById('stroke-weight');
      const strokeWeightLabel = document.getElementById('stroke-weight-label'); // Reference for potential future use

      // --- State Variables ---
      // Gradient stops data model
      let stops = [
        { id: 'start-stop', position: 0, color: '#ff0000', alpha: 1, isEndpoint: true },
        { id: 'end-stop', position: 100, color: '#0000ff', alpha: 1, isEndpoint: true }
      ];
      let selectedStopId = null; // ID of the currently selected stop

      // Color stop dragging state
      let isDragging = false;        // Is a color stop being dragged?
      let activeDragElement = null; // The DOM element being dragged
      let dragStartX, dragStartLeft; // Initial position during drag start

      // Stroke weight dragging state
      let isDraggingWeight = false;       // Is the stroke weight being dragged?
      let weightDragStartX = 0;         // Initial mouse X position for weight drag
      let weightDragLastX = 0;          // Last mouse X position during weight drag
      let weightDragCurrentValue = 0;   // Current weight value during drag
      let weightDragEngaged = false;    // Has the cursor changed to indicate dragging?
      let weightScalingActive = false;  // Has the value scaling started (moved enough)?


      // --- Initialization ---

      // Initial setup on page load
      document.addEventListener('DOMContentLoaded', () => {
          initializeCustomSelects(); // Set up custom dropdowns
          setupInitialStopHandlers(); // Attach handlers to start/end stops
          positionStops();           // Position initial stops correctly
          updateGradient();          // Render the initial gradient bar
          selectStop('start-stop');    // Select the start stop by default
          setupPanelInputListeners(); // Add listeners for panel inputs
          setupWeightDragListeners(); // Add listeners for weight input dragging
          setupKeyboardListeners();   // Add global keyboard listeners (delete)
          setupGradientBarClickListener(); // *** ADDED: Listener for gradient bar clicks ***

          // Request initial data from the plugin (if applicable)
          // parent.postMessage({ pluginMessage: { type: 'get-initial-data' } }, '*');
      });

      // Close custom selects when clicking outside
      document.addEventListener("click", closeAllSelect);

      // Handle window resize
      window.addEventListener('resize', () => {
         positionStops();
         updateGradient(); // Redraw gradient as bar width changes
      });

      // --- Custom Select Dropdown Logic ---

      // Closes all custom select dropdowns except the one passed as elmnt
      function closeAllSelect(elmnt) {
        const selectItems = document.getElementsByClassName("select-items");
        const selectedBoxes = document.getElementsByClassName("select-selected");
        const activeIndices = [];

        // Find the index of the element being interacted with
        for (let i = 0; i < selectedBoxes.length; i++) {
          if (elmnt === selectedBoxes[i]) {
            activeIndices.push(i);
          } else {
            selectedBoxes[i].classList.remove("select-arrow-active");
          }
        }
        // Hide all dropdowns that are not the active one
        for (let i = 0; i < selectItems.length; i++) {
          // Check if the parent wrapper does NOT have the 'join-options-visible' class
          const wrapper = selectItems[i].closest('.custom-select-wrapper');
          if (!wrapper || !wrapper.classList.contains('join-options-visible')) {
            if (activeIndices.indexOf(i) === -1) { // If index is not in active list
              selectItems[i].classList.add("select-hide");
            }
          }
        }
      }

      // Initializes all elements with the class "custom-select"
      function initializeCustomSelects() {
          const customSelects = document.getElementsByClassName("custom-select");
          for (let i = 0; i < customSelects.length; i++) {
              const customSelectDiv = customSelects[i];
              const wrapper = customSelectDiv.closest('.custom-select-wrapper');
              const hiddenInput = wrapper?.querySelector('input[type="hidden"]');
              const selectedDisplay = customSelectDiv.querySelector(".select-selected");
              const itemsContainer = customSelectDiv.querySelector(".select-items");

              if (!hiddenInput || !selectedDisplay || !itemsContainer) {
                  console.warn("Skipping malformed custom select:", customSelectDiv);
                  continue;
              }

              const isJoinSelector = wrapper.classList.contains('join-options-visible'); // Check for the class

              const options = itemsContainer.getElementsByClassName("select-option");

              // Set initial display / selected state
              const initialValue = hiddenInput.value;
              let initialHTML = 'Select...'; // Fallback for dropdowns
              for (let k = 0; k < options.length; k++) {
                  if (options[k].getAttribute('data-value') === initialValue) {
                      initialHTML = options[k].innerHTML; // Get HTML for dropdowns
                      options[k].classList.add("same-as-selected");
                      if (!isJoinSelector) { // Only move to top for dropdowns
                         itemsContainer.prepend(options[k]);
                      }
                      break;
                  }
              }
              if (!isJoinSelector) { // Only set display HTML for dropdowns
                  selectedDisplay.innerHTML = initialHTML;
              }


              // --- Conditional Listeners ---

              if (!isJoinSelector) {
                  // == STANDARD DROPDOWN LOGIC (for Start/End caps) ==
                  selectedDisplay.addEventListener("click", function(e) {
                      e.stopPropagation();
                      closeAllSelect(this); // Close others
                      itemsContainer.classList.toggle("select-hide");
                      this.classList.toggle("select-arrow-active");
                  });

                  // Basic keyboard nav for dropdowns (optional)
                  selectedDisplay.addEventListener("keydown", function(e) {
                      if (e.key === 'Enter' || e.key === ' ') {
                          e.preventDefault();
                          this.click(); // Open/close dropdown
                      }
                  });

                  for (let j = 0; j < options.length; j++) {
                      options[j].addEventListener("click", function() {
                          const newValue = this.getAttribute("data-value");
                          selectedDisplay.innerHTML = this.innerHTML;
                          hiddenInput.value = newValue;

                          const siblings = this.parentNode.children;
                          for (let k = 0; k < siblings.length; k++) {
                              siblings[k].classList.remove("same-as-selected");
                          }
                          this.classList.add("same-as-selected");
                          this.parentNode.prepend(this); // Move selected option to the top
                          selectedDisplay.click(); // Close dropdown
                      });
                  }
              } else {
                  // == ALWAYS VISIBLE LOGIC (for Join) ==
                  // No click listener needed for selectedDisplay (it's hidden)
                  // No keydown listener needed for selectedDisplay

                  for (let j = 0; j < options.length; j++) {
                      options[j].addEventListener("click", function() {
                          const newValue = this.getAttribute("data-value");
                          hiddenInput.value = newValue; // Update hidden input

                          // Update styling for selected option
                          const siblings = this.parentNode.children;
                          for (let k = 0; k < siblings.length; k++) {
                              siblings[k].classList.remove("same-as-selected");
                          }
                          this.classList.add("same-as-selected");
                          // No need to close anything
                      });
                  }
              }
          }
      }


      // --- Gradient Stop Management ---

      // Selects a color stop visually and updates the panel
      function selectStop(stopId) {
          // If already selected, ensure class is present (handles edge cases)
          if (selectedStopId === stopId) {
              const currentEl = document.getElementById(stopId);
              if (currentEl && !currentEl.classList.contains('selected')) {
                  currentEl.classList.add('selected');
              }
              return; // No change needed
          }

          // Deselect previous stop
          if (selectedStopId) {
              const previousEl = document.getElementById(selectedStopId);
              previousEl?.classList.remove('selected');
          }

          // Select the new stop
          const stopElement = document.getElementById(stopId);
          if (stopElement) {
              stopElement.classList.add('selected');
              selectedStopId = stopId;
              updateStopPanel(); // Update panel based on new selection
              // Optional: Notify plugin about selection change
              // parent.postMessage({ pluginMessage: { type: 'select-stop', selectedStopId: stopId } }, '*');
          } else {
              console.warn(`selectStop called for non-existent ID: ${stopId}`);
              selectedStopId = null; // Clear selection if stop doesn't exist
              updateStopPanel(); // Clear panel
          }
      }

      // Positions all stop elements visually based on their data
      function positionStops() {
          const gradientWidth = gradientBar.offsetWidth;
          stops.forEach(stop => {
              const stopElement = document.getElementById(stop.id);
              if (stopElement) {
                  stopElement.style.left = `${(stop.position / 100) * gradientWidth}px`;
              }
          });
      }

      // Updates the gradient bar background based on current stops
      function updateGradient() {
          if (!Array.isArray(stops) || stops.length === 0) {
              console.error("Invalid 'stops' array for gradient update:", stops);
              gradientBar.style.background = 'grey'; // Fallback
              return;
          }

          // Sort stops by position for correct gradient generation
          let sortedStops = [...stops].sort((a, b) => a.position - b.position);

          // Create the CSS linear-gradient string including alpha
          let gradientString = sortedStops
              .map(stop => {
                  const alpha = stop.alpha !== undefined ? stop.alpha : 1;
                  const rgba = hexToRgba(stop.color, alpha); // Convert hex + alpha to rgba()
                  return `${rgba} ${stop.position}%`;
              })
              .join(', ');

          gradientBar.style.background = `linear-gradient(to right, ${gradientString})`;

          // Update visual representation of stops (position and preview color)
          stops.forEach(stop => {
              const stopElement = document.getElementById(stop.id);
              if (stopElement) {
                  // Update position (redundant if called after positionStops, but safe)
                  stopElement.style.left = `${(stop.position / 100) * gradientBar.offsetWidth}px`;
                  // Update preview color (uses hex color without alpha)
                  const preview = stopElement.querySelector('.color-preview');
                  if (preview) preview.style.backgroundColor = stop.color;
                  // Update hidden color input value (uses hex color without alpha)
                  const input = stopElement.querySelector('input[type="color"]');
                  if (input) input.value = stop.color;
              }
          });

          updateStopPanel(); // Keep the editor panel synchronized
      }

      // Adds a new color stop to the data model and the DOM
      function addNewStop(position, colorData) {
          if (typeof position !== 'number' || position < 0 || position > 100) {
              console.error("Invalid stop position:", position);
              return;
          }
          const stopId = `stop-${Date.now()}`; // Generate unique ID
          const newStop = {
              id: stopId,
              position: Math.round(position), // Ensure integer position
              color: colorData.color,
              alpha: colorData.alpha !== undefined ? colorData.alpha : 1,
              isEndpoint: false // New stops are never endpoints
          };
          stops.push(newStop);

          // Create DOM element for the new stop
          const stopElement = document.createElement('div');
          stopElement.classList.add('color-stop');
          stopElement.id = stopId;
          stopElement.innerHTML = `
              <div class="color-preview" style="background: ${newStop.color}"></div>
              <input type="color" value="${newStop.color}">`;
          colorStops.appendChild(stopElement); // Add to container

          // Position the new stop element
          positionStops(); // Reposition all stops including the new one

          // Setup handlers for the new stop
          setupColorInputHandler(stopId); // Color input/preview click
          const colorPreview = stopElement.querySelector('.color-preview');
          if (colorPreview) {
              colorPreview.addEventListener('mousedown', (e) => handleStopDragStart(e, stopElement)); // Dragging
          }

          updateGradient(); // Update gradient display
          selectStop(stopId); // Select the newly added stop
      }

      // Deletes a color stop from the data model and the DOM
      function deleteStop(stopId) {
          const stopIndex = stops.findIndex(s => s.id === stopId);
          if (stopIndex === -1) return; // Stop not found

          const stop = stops[stopIndex];
          if (stop.isEndpoint) return; // Cannot delete endpoints

          // Remove DOM element
          const stopElement = document.getElementById(stopId);
          stopElement?.remove();

          // Remove from data array
          stops.splice(stopIndex, 1);

          // If the deleted stop was selected, select another stop
          if (selectedStopId === stopId) {
              // Select the first non-endpoint stop, or the start stop as fallback
              const nextStopToSelect = stops.find(s => !s.isEndpoint)?.id || stops[0]?.id || null;
              selectStop(nextStopToSelect);
          }

          updateGradient(); // Update UI
      }

      // --- Stop Dragging Logic ---

      // Sets up event listeners for a specific stop's color input and preview click
      function setupColorInputHandler(stopId) {
          const stopElement = document.getElementById(stopId);
          if (!stopElement) return;
          const colorInput = stopElement.querySelector('input[type="color"]'); // Hidden color picker
          const colorPreview = stopElement.querySelector('.color-preview'); // Visible preview circle

          // Handle changes from the hidden color picker
          if (colorInput) {
              colorInput.addEventListener('input', (e) => {
                  const stopObj = stops.find(s => s.id === stopId);
                  if (stopObj) {
                      stopObj.color = e.target.value; // Update color in data model
                      if (colorPreview) colorPreview.style.backgroundColor = e.target.value; // Update preview visually
                      updateGradient(); // Redraw gradient and update panel
                  }
              });
          }

          // Handle clicks on the visible preview circle
          if (colorPreview) {
              colorPreview.addEventListener('click', () => {
                  if (!isDragging) { // Only trigger if not currently dragging this stop
                      selectStop(stopId); // Select the stop
                      colorInput?.click(); // Open the hidden color picker
                  }
              });
          }
      }

      // Initializes drag handlers for the initial start and end stops
      function setupInitialStopHandlers() {
          setupColorInputHandler('start-stop');
          setupColorInputHandler('end-stop');
          startPreview.addEventListener('mousedown', (e) => handleStopDragStart(e, startStop));
          endPreview.addEventListener('mousedown', (e) => handleStopDragStart(e, endStop));
      }

      // Handles the start of dragging a color stop
      function handleStopDragStart(e, element) {
          if (e.button !== 0) return; // Only respond to left-click
          e.preventDefault(); // Prevent default text selection/drag behaviors
          isDragging = true;
          activeDragElement = element;
          selectStop(element.id); // Select the stop being dragged
          dragStartX = e.clientX; // Record starting mouse position
          dragStartLeft = parseInt(window.getComputedStyle(element).left || '0'); // Record starting element position

          // Add temporary listeners to the document for move and mouseup
          document.addEventListener('mousemove', handleStopDragMove);
          document.addEventListener('mouseup', handleStopDragEnd, { once: true }); // Remove after first trigger
      }

      // Handles mouse movement while dragging a color stop
      function handleStopDragMove(e) {
          if (!isDragging || !activeDragElement) return;
          e.preventDefault(); // Prevent selection during drag

          const gradientRect = gradientBar.getBoundingClientRect();
          const minX = 0; // Minimum pixel position (left edge of bar)
          const maxX = gradientRect.width; // Maximum pixel position (right edge of bar)

          // Calculate new horizontal position based on mouse movement
          let newLeft = dragStartLeft + (e.clientX - dragStartX);
          newLeft = Math.max(minX, Math.min(newLeft, maxX)); // Clamp position within bar bounds

          // Calculate percentage position
          const position = Math.round((newLeft / maxX) * 100);

          // Update the stop's data model
          const stopId = activeDragElement.id;
          const stop = stops.find(s => s.id === stopId);
          if (stop) {
              stop.position = position; // Update position in the data array
              activeDragElement.style.left = `${newLeft}px`; // Update visual position immediately
              updateGradient(); // Redraw gradient bar and update panel
          }
      }

      // Handles the end of dragging a color stop
      function handleStopDragEnd() {
          if (isDragging) {
              isDragging = false;
              activeDragElement = null;
              document.removeEventListener('mousemove', handleStopDragMove);
              // mouseup listener is removed automatically due to { once: true }
              // Final update to ensure consistency (might be redundant but safe)
              updateGradient();
          }
      }

      // --- Gradient Bar Click Listener ---

      // *** ADDED: Sets up the click listener for the gradient bar ***
      function setupGradientBarClickListener() {
          gradientBar.addEventListener('click', (e) => {
              // Ignore clicks if not directly on the bar itself, or if a stop is being dragged
              if (e.target !== gradientBar || isDragging) return;

              const gradientRect = gradientBar.getBoundingClientRect();
              const clickX = e.clientX - gradientRect.left; // Click position relative to the bar
              const positionPercent = Math.round((clickX / gradientRect.width) * 100); // Position as percentage

              // Get the interpolated color and alpha at the click position
              const colorData = getColorAtPosition(positionPercent);

              // Add the new stop using the calculated position and color data
              addNewStop(positionPercent, colorData);
          });
      }

      // --- Stop Editor Panel Logic ---

      // Updates the editor panel fields based on the currently selected stop
      function updateStopPanel() {
          const stop = stops.find(s => s.id === selectedStopId);

          if (!stop) {
              // Clear/disable panel if no stop is selected
              currentStopPosition.value = '';
              currentStopColor.value = '';
              currentStopColorPreview.style.backgroundColor = 'transparent';
              currentStopAlpha.value = '';
              removeStopBtn.disabled = true; // Disable remove button
              currentStopPosition.disabled = true; // Disable inputs
              currentStopColor.disabled = true;
              currentStopAlpha.disabled = true;
              currentStopColorPreview.style.cursor = 'default';
              return;
          }

          // Enable inputs and set values
          currentStopPosition.disabled = false;
          currentStopColor.disabled = false;
          currentStopAlpha.disabled = false;
          currentStopColorPreview.style.cursor = 'pointer';

          currentStopPosition.value = stop.position + '%'; // Format position with %
          currentStopColor.value = stop.color; // Set hex color
          currentStopColorPreview.style.backgroundColor = stop.color; // Update color preview swatch
          currentStopAlpha.value = Math.round((stop.alpha !== undefined ? stop.alpha : 1) * 100); // Set alpha (0-100)

          // Disable remove button for endpoint stops
          removeStopBtn.disabled = stop.isEndpoint;
      }

      // Sets up event listeners for the input fields in the stop editor panel
      function setupPanelInputListeners() {
          // Position Input (Text Input)
          currentStopPosition.addEventListener('input', handlePositionInput);
          currentStopPosition.addEventListener('blur', handlePositionBlur);
          currentStopPosition.addEventListener('keydown', handlePositionKeydown);
          currentStopPosition.addEventListener('focus', (e) => e.target.select()); // Select text on focus

          // Color Input (Text Input for Hex)
          currentStopColor.addEventListener('input', handleColorInput);
          currentStopColor.addEventListener('blur', handleColorBlur);
          currentStopColor.addEventListener('focus', (e) => e.target.select()); // Select text on focus

          // Alpha Input (Number Input)
          currentStopAlpha.addEventListener('input', handleAlphaInput);
          currentStopAlpha.addEventListener('blur', handleAlphaBlur);
          currentStopAlpha.addEventListener('focus', (e) => e.target.select()); // Select text on focus

          // Panel Color Preview Click (opens hidden color picker for the selected stop)
          currentStopColorPreview.addEventListener('click', () => {
              if (!selectedStopId) return;
              const stopElement = document.getElementById(selectedStopId);
              const colorInput = stopElement?.querySelector('input[type="color"]');
              colorInput?.click();
          });

          // Add/Remove Buttons
          addStopBtn.addEventListener('click', handleAddStopClick);
          removeStopBtn.addEventListener('click', handleRemoveStopClick);

          // Highlight color input when alpha is focused
           currentStopAlpha.addEventListener('focus', () => currentStopColor.classList.add('highlight'));
           currentStopAlpha.addEventListener('blur', () => currentStopColor.classList.remove('highlight'));
      }

      // Handlers for Panel Inputs
      function handlePositionInput(e) {
          if (!selectedStopId) return;
          const stop = stops.find(s => s.id === selectedStopId);
          if (!stop) return;
          let value = e.target.value.replace('%', '');
          let newPosition = parseInt(value);
          if (!isNaN(newPosition)) {
              // Allow temporary overshoot during typing, clamp on update/blur
              newPosition = Math.max(-10, Math.min(110, newPosition)); // Allow slight overshoot temp
              if (stop.position !== newPosition) {
                  stop.position = newPosition;
                  updateGradient(); // Updates element position and reformats panel value
              }
          }
      }
      function handlePositionBlur(e) {
          if (!selectedStopId) return;
          const stop = stops.find(s => s.id === selectedStopId);
          if (!stop) return;
          let value = e.target.value.replace('%', '');
          let numValue = parseInt(value);
          if (!isNaN(numValue)) {
              numValue = Math.max(0, Math.min(100, numValue)); // Clamp strictly on blur
              stop.position = numValue;
              e.target.value = numValue + '%'; // Reformat input
              updateGradient();
          } else {
              e.target.value = stop.position + '%'; // Revert if invalid
          }
      }
      function handlePositionKeydown(e) { // Arrow key handling
          if (!selectedStopId || (e.key !== 'ArrowUp' && e.key !== 'ArrowDown')) return;
          e.preventDefault();
          const stop = stops.find(s => s.id === selectedStopId);
          if (!stop) return;
          let currentVal = parseInt(currentStopPosition.value.replace('%', ''));
          if (isNaN(currentVal)) currentVal = stop.position;
          const step = e.shiftKey ? 10 : 1;
          currentVal += (e.key === 'ArrowUp' ? step : -step);
          currentVal = Math.max(0, Math.min(100, currentVal)); // Clamp
          currentStopPosition.value = currentVal + '%';
          if (stop.position !== currentVal) {
              stop.position = currentVal;
              updateGradient();
          }
      }
      function handleColorInput(e) {
          if (!selectedStopId) return;
          const stop = stops.find(s => s.id === selectedStopId);
          if (!stop) return;
          const parsed = parseHexWithOptionalAlpha(e.target.value); // Use improved parser
          if (parsed) {
              const newAlpha = parsed.alphaPercent / 100;
              if (stop.color !== parsed.color || stop.alpha !== newAlpha) {
                  stop.color = parsed.color;
                  stop.alpha = newAlpha;
                  currentStopColorPreview.style.backgroundColor = stop.color;
                  currentStopAlpha.value = parsed.alphaPercent; // Update alpha input
                  // Update hidden input in the actual stop element
                  const stopElement = document.getElementById(selectedStopId);
                  const hiddenInput = stopElement?.querySelector('input[type="color"]');
                  if (hiddenInput) hiddenInput.value = stop.color;
                  updateGradient();
              }
          }
      }
      function handleColorBlur(e) {
          if (!selectedStopId) return;
          const stop = stops.find(s => s.id === selectedStopId);
          if (!stop) return;
          const parsed = parseHexWithOptionalAlpha(e.target.value);
          // On blur, always display the canonical #rrggbb format, even if alpha was entered
          e.target.value = stop.color;
          // If input was invalid, the model wasn't updated, so reverting input to stop.color is correct.
          // If input *was* valid (e.g., #rrggbbaa), model was updated, and we still set input to stop.color (#rrggbb).
      }
      function handleAlphaInput(e) {
          if (!selectedStopId) return;
          const stop = stops.find(s => s.id === selectedStopId);
          if (!stop) return;
          let alphaPercent = parseInt(e.target.value);
          if (!isNaN(alphaPercent)) {
              alphaPercent = Math.max(0, Math.min(100, alphaPercent)); // Clamp 0-100
              const newAlpha = alphaPercent / 100;
              if (stop.alpha !== newAlpha) {
                  stop.alpha = newAlpha;
                  updateGradient();
              }
          }
      }
      function handleAlphaBlur(e) {
          if (!selectedStopId) return;
          const stop = stops.find(s => s.id === selectedStopId);
          if (!stop) return;
          let alphaPercent = parseInt(e.target.value);
          if (isNaN(alphaPercent)) {
              // Revert to current model value if input is invalid
              e.target.value = Math.round((stop.alpha !== undefined ? stop.alpha : 1) * 100);
          } else {
              // Ensure clamped value is displayed and update model if needed
              alphaPercent = Math.max(0, Math.min(100, alphaPercent));
              e.target.value = alphaPercent; // Display clamped value
              const newAlpha = alphaPercent / 100;
              if (stop.alpha !== newAlpha) {
                  stop.alpha = newAlpha;
                  updateGradient();
              }
          }
      }
      function handleAddStopClick() {
          const sortedStops = [...stops].sort((a, b) => a.position - b.position);
          let position = 50; // Default position
          let colorData = { color: "#808080", alpha: 1 }; // Default color/alpha

          if (sortedStops.length >= 2) {
              // Find the largest gap between existing stops
              let largestGap = 0;
              let insertPos = 50; // Default insert position
              for (let i = 0; i < sortedStops.length - 1; i++) {
                  let gap = sortedStops[i + 1].position - sortedStops[i].position;
                  if (gap > largestGap) {
                      largestGap = gap;
                      insertPos = Math.round(sortedStops[i].position + gap / 2);
                  }
              }
              position = insertPos;
              colorData = getColorAtPosition(position); // Get interpolated color/alpha
          }
          addNewStop(position, colorData);
      }
      function handleRemoveStopClick() {
          const stop = stops.find(s => s.id === selectedStopId);
          if (stop && !stop.isEndpoint) { // Ensure selected and not endpoint
              deleteStop(selectedStopId);
          }
      }

      // --- Stroke Weight Input Logic ---

      // Sets up listeners for the stroke weight input (drag and keyboard)
      function setupWeightDragListeners() {
          strokeWeightInput.addEventListener('keydown', handleWeightKeydown);
          strokeWeightInput.addEventListener('mousedown', handleWeightMouseDown);
          strokeWeightInput.addEventListener('focus', (e) => e.target.select()); // Select text on focus
      }

      // Handles Shift + Arrow Up/Down for stroke weight input
      function handleWeightKeydown(e) {
          if (e.key !== 'ArrowUp' && e.key !== 'ArrowDown') return;
          e.preventDefault(); // Prevent default input stepping

          const step = e.shiftKey ? 10 : 1; // Larger step with Shift
          const minVal = parseFloat(strokeWeightInput.min) || 0;
          const maxVal = parseFloat(strokeWeightInput.max); // Check if max is defined
          let currentValue = parseFloat(strokeWeightInput.value) || 0;

          currentValue += (e.key === 'ArrowUp' ? step : -step);

          // Clamp value within min/max bounds
          currentValue = Math.max(minVal, currentValue);
          if (!isNaN(maxVal)) {
              currentValue = Math.min(maxVal, currentValue);
          }

          strokeWeightInput.value = Math.round(currentValue); // Use rounded value for weight
          // Optionally trigger input event:
          // strokeWeightInput.dispatchEvent(new Event('input', { bubbles: true }));
      }

      // Handles mousedown on the stroke weight input to initiate drag
      function handleWeightMouseDown(e) {
          if (e.button !== 0) return; // Only left click

          const isFocused = (document.activeElement === strokeWeightInput);

          // Prevent default ONLY if starting drag from an unfocused state
          if (!isFocused) {
              e.preventDefault();
              strokeWeightInput.focus(); // Manually focus
          }
          // If focused, allow default behavior (cursor placement)

          // Proceed with setting up drag state
          isDraggingWeight = true;
          weightDragStartX = e.clientX;
          weightDragLastX = e.clientX;
          weightDragCurrentValue = parseFloat(strokeWeightInput.value) || 0;
          weightDragEngaged = false;
          weightScalingActive = false;

          // Add listeners
          document.addEventListener('mousemove', handleWeightDragMove);
          document.addEventListener('mouseup', handleWeightDragEnd, { once: true });
      }


      // Handles mouse movement during stroke weight drag
      function handleWeightDragMove(e) {
          if (!isDraggingWeight) return;
          e.preventDefault(); // Prevent text selection during move

          const currentX = e.clientX;
          const deltaX = Math.abs(currentX - weightDragStartX);

          // Engage cursor change visual cue
          if (!weightDragEngaged && deltaX > 2) {
              weightDragEngaged = true;
              document.body.style.cursor = 'ew-resize';
              strokeWeightInput.style.cursor = 'ew-resize';
          }

          // Activate value scaling
          if (!weightScalingActive && deltaX > 4) {
              weightScalingActive = true;
              weightDragLastX = currentX;
          }

          // Perform scaling if active
          if (weightScalingActive) {
              const moveDeltaX = currentX - weightDragLastX;
              const scaleFactor = e.shiftKey ? 1.0 : 0.1;
              const valueChange = moveDeltaX * scaleFactor;

              weightDragCurrentValue += valueChange;

              // Clamp value
              const minVal = parseFloat(strokeWeightInput.min) || 0;
              const maxVal = parseFloat(strokeWeightInput.max);
              weightDragCurrentValue = Math.max(minVal, weightDragCurrentValue);
              if (!isNaN(maxVal)) {
                  weightDragCurrentValue = Math.min(maxVal, weightDragCurrentValue);
              }

              strokeWeightInput.value = Math.round(weightDragCurrentValue);
              weightDragLastX = currentX;
          }
      }

      // Handles mouseup after stroke weight drag
      function handleWeightDragEnd() {
          if (!isDraggingWeight) return;

          // Finalize value if scaling occurred
          if (weightScalingActive) {
              let finalValue = parseFloat(strokeWeightInput.value) || 0;
              const minVal = parseFloat(strokeWeightInput.min) || 0;
              const maxVal = parseFloat(strokeWeightInput.max);
              finalValue = Math.max(minVal, finalValue);
              if (!isNaN(maxVal)) {
                  finalValue = Math.min(maxVal, finalValue);
              }
              strokeWeightInput.value = Math.round(finalValue);
          }

          // Reset states and listeners
          isDraggingWeight = false;
          weightDragEngaged = false;
          weightScalingActive = false;
          document.removeEventListener('mousemove', handleWeightDragMove);
          document.body.style.cursor = '';
          strokeWeightInput.style.cursor = '';
      }


      // --- Keyboard Listeners ---

      // Sets up global keyboard listeners (e.g., for deleting stops)
      function setupKeyboardListeners() {
          document.addEventListener('keydown', (e) => {
              const activeElement = document.activeElement;
              // Check if focus is NOT inside an input/select/textarea or custom select
              const isInputFocused = activeElement.tagName === 'INPUT' ||
                                     activeElement.tagName === 'SELECT' ||
                                     activeElement.tagName === 'TEXTAREA' ||
                                     activeElement.classList.contains('select-selected');

              // Handle Delete/Backspace for selected color stop if focus is not in an input
              if (!isInputFocused && (e.key === 'Delete' || e.key === 'Backspace') && selectedStopId) {
                  e.preventDefault(); // Prevent browser back navigation on Backspace
                  const stop = stops.find(s => s.id === selectedStopId);
                  if (stop && !stop.isEndpoint) { // Can only delete non-endpoint stops
                      deleteStop(selectedStopId);
                      // Optional: Notify plugin about key press
                      // parent.postMessage({ pluginMessage: { type: 'handle-key-press', key: e.key, selectedStopId: selectedStopId } }, '*');
                  }
              }
          });
      }

      // --- Utility Functions ---

      // Converts a hex color and alpha (0-1) to an rgba string
      function hexToRgba(hex, alpha) {
          hex = hex.replace('#', '');
          let r, g, b;
          if (hex.length === 3) { // Expand shorthand hex
              r = parseInt(hex[0] + hex[0], 16);
              g = parseInt(hex[1] + hex[1], 16);
              b = parseInt(hex[2] + hex[2], 16);
          } else if (hex.length === 6) { // Standard hex
              r = parseInt(hex.substring(0, 2), 16);
              g = parseInt(hex.substring(2, 4), 16);
              b = parseInt(hex.substring(4, 6), 16);
          } else { // Invalid hex
              r = g = b = 128; // Default to gray
          }
          alpha = Math.max(0, Math.min(1, alpha)); // Clamp alpha 0-1
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      // Interpolates color and alpha between two stops at a given ratio (0-1)
      function getColorAtPosition(positionPercent) {
          const sortedStops = [...stops].sort((a, b) => a.position - b.position);
          if (sortedStops.length === 0) return { color: '#808080', alpha: 1 }; // Default if no stops
          if (sortedStops.length === 1) return { color: sortedStops[0].color, alpha: sortedStops[0].alpha ?? 1 };

          // Find the two stops the position falls between
          let prevStop = sortedStops[0];
          let nextStop = sortedStops[sortedStops.length - 1];
          if (positionPercent <= prevStop.position) return { color: prevStop.color, alpha: prevStop.alpha ?? 1 };
          if (positionPercent >= nextStop.position) return { color: nextStop.color, alpha: nextStop.alpha ?? 1 };

          for (let i = 0; i < sortedStops.length - 1; i++) {
              if (sortedStops[i].position <= positionPercent && sortedStops[i + 1].position >= positionPercent) {
                  prevStop = sortedStops[i];
                  nextStop = sortedStops[i + 1];
                  break;
              }
          }

          // Calculate interpolation ratio
          const range = nextStop.position - prevStop.position;
          const ratio = (range === 0) ? 1 : (positionPercent - prevStop.position) / range; // Avoid division by zero

          // Interpolate color and alpha
          const interpolatedColor = interpolateColor(prevStop.color, nextStop.color, ratio);
          const prevAlpha = prevStop.alpha ?? 1;
          const nextAlpha = nextStop.alpha ?? 1;
          const interpolatedAlpha = prevAlpha + (nextAlpha - prevAlpha) * ratio;

          return { color: interpolatedColor, alpha: interpolatedAlpha };
      }

      // Linearly interpolates between two hex colors based on a ratio (0-1)
      function interpolateColor(color1, color2, ratio) {
          const parseHex = (hex) => { // Helper to parse hex to RGB object
              hex = (hex || '#000000').replace('#', '');
              let r, g, b;
              if (hex.length === 3) {
                  r = parseInt(hex[0] + hex[0], 16); g = parseInt(hex[1] + hex[1], 16); b = parseInt(hex[2] + hex[2], 16);
              } else if (hex.length === 6) {
                  r = parseInt(hex.substring(0, 2), 16); g = parseInt(hex.substring(2, 4), 16); b = parseInt(hex.substring(4, 6), 16);
              } else { return { r: 0, g: 0, b: 0 }; } // Invalid format
              return { r, g, b };
          };
          const rgb1 = parseHex(color1);
          const rgb2 = parseHex(color2);
          const clamp = (val) => Math.max(0, Math.min(255, Math.round(val))); // Clamp 0-255 and round
          const r = clamp(rgb1.r + (rgb2.r - rgb1.r) * ratio);
          const g = clamp(rgb1.g + (rgb2.g - rgb1.g) * ratio);
          const b = clamp(rgb1.b + (rgb2.b - rgb1.b) * ratio);
          const componentToHex = (c) => c.toString(16).padStart(2, '0'); // Convert number to 2-digit hex
          return `#${componentToHex(r)}${componentToHex(g)}${componentToHex(b)}`;
      }

      // Parses hex color string (#rgb, #rrggbb, #rrggbbaa, or without #)
      // Returns { color: '#rrggbb', alphaPercent: 0-100 } or null if invalid
      function parseHexWithOptionalAlpha(hexColor) {
          hexColor = hexColor.trim().replace('#', ''); // Clean input
          let r, g, b, a = 255; // Default alpha is 100% (FF)

          if (/^[0-9A-Fa-f]{3}$/.test(hexColor)) { // #rgb
              r = parseInt(hexColor[0] + hexColor[0], 16);
              g = parseInt(hexColor[1] + hexColor[1], 16);
              b = parseInt(hexColor[2] + hexColor[2], 16);
          } else if (/^[0-9A-Fa-f]{6}$/.test(hexColor)) { // #rrggbb
              r = parseInt(hexColor.substring(0, 2), 16);
              g = parseInt(hexColor.substring(2, 4), 16);
              b = parseInt(hexColor.substring(4, 6), 16);
          } else if (/^[0-9A-Fa-f]{8}$/.test(hexColor)) { // #rrggbbaa
              r = parseInt(hexColor.substring(0, 2), 16);
              g = parseInt(hexColor.substring(2, 4), 16);
              b = parseInt(hexColor.substring(4, 6), 16);
              a = parseInt(hexColor.substring(6, 8), 16); // Get alpha value
          } else {
              return null; // Invalid format
          }

          const componentToHex = (c) => c.toString(16).padStart(2, '0');
          const finalColor = `#${componentToHex(r)}${componentToHex(g)}${componentToHex(b)}`;
          const finalAlphaPercent = Math.round((a / 255) * 100);

          return { color: finalColor, alphaPercent: finalAlphaPercent };
      }


      // --- Communication with Plugin (Example Functions) ---

      // Sends the final gradient data to the plugin
      function applyGradient() {
          try {
              const strokeWeight = strokeWeightInput.value;
              const startCap = document.getElementById('start-cap-value').value;
              const endCap = document.getElementById('end-cap-value').value;
              const strokeJoin = document.getElementById('stroke-join-value').value;

              if (!Array.isArray(stops) || stops.length < 2) {
                  console.error("Stops array invalid for apply:", stops);
                  alert("Error: Minimum 2 gradient stops required.");
                  return;
              }

              // Prepare stops data for the plugin (ensure position 0-100, alpha 0-1)
              const processedStops = stops.map(stop => {
                  return {
                      position: Math.max(0, Math.min(100, Number(stop.position) || 0)),
                      color: stop.color || '#000000',
                      alpha: stop.alpha !== undefined ? Math.max(0, Math.min(1, stop.alpha)) : 1
                  };
              }).sort((a, b) => a.position - b.position); // Ensure sorted by position

              // Send message to the plugin environment
              parent.postMessage({
                  pluginMessage: {
                      type: 'apply-gradient',
                      strokeWeight: parseFloat(strokeWeight) || 0,
                      startCap: startCap,
                      endCap: endCap,
                      strokeJoin: strokeJoin,
                      stops: processedStops
                  }
              }, '*'); // Use specific origin in production if possible
          } catch (error) {
              console.error("Error in applyGradient:", error);
              alert("Error applying gradient: " + error.message);
          }
      }

      // Handles messages received from the plugin
      window.onmessage = (event) => {
          // Basic security check (optional but recommended)
          // if (event.origin !== 'expected_plugin_origin') return;

          const msg = event.data.pluginMessage;
          if (!msg) return; // Ignore messages not conforming to expected structure

          console.log("Message from plugin:", msg); // For debugging

          switch (msg.type) {
              case 'selection-error':
                  alert('Plugin Error: ' + (msg.message || 'Please select a single vector path.'));
                  break;

              case 'init-data': // Plugin sends initial state
                  handleInitData(msg);
                  break;

              case 'stop-selected': // Plugin requests UI to select a stop
                  if (msg.stopId && document.getElementById(msg.stopId)) {
                      selectStop(msg.stopId);
                  }
                  break;

              case 'show-color-picker-for-stop': // Plugin requests color picker for a stop
                  if (msg.stopId) {
                      const stopElement = document.getElementById(msg.stopId);
                      const colorInput = stopElement?.querySelector('input[type="color"]');
                      colorInput?.click();
                  }
                  break;

              // Add other message types as needed
          }
      };

      // Processes initial data received from the plugin
      function handleInitData(msg) {
          // Update Stroke Properties
          if (msg.strokeWeight !== undefined) strokeWeightInput.value = msg.strokeWeight;

          // Update Custom Selects (Start/End Caps AND Join)
          updateCustomSelectFromData('start-cap', msg.startCap);
          updateCustomSelectFromData('end-cap', msg.endCap);
          updateCustomSelectFromData('stroke-join', msg.strokeJoin);

          // Update Gradient Stops
          if (Array.isArray(msg.stops)) {
              // Clear existing non-endpoint DOM elements
              colorStops.querySelectorAll('.color-stop:not(#start-stop):not(#end-stop)')
                  .forEach(el => el.remove());

              // Rebuild stops array from message (expecting position 0-100, alpha 0-1)
              stops = msg.stops.map((pluginStop, index) => {
                  let id = pluginStop.id; // Use ID from plugin if provided
                  const position = Math.max(0, Math.min(100, pluginStop.position || 0));
                  const isEndpoint = (position === 0 || position === 100);

                  // Ensure start/end stops use fixed IDs, generate for others if needed
                  if (position === 0 && !id) id = 'start-stop';
                  else if (position === 100 && !id) id = 'end-stop';
                  else if (!id && !isEndpoint) id = `stop-${Date.now()}-${index}`; // Generate ID

                  return {
                      id: id,
                      position: position,
                      color: pluginStop.color || '#000000',
                      alpha: pluginStop.alpha !== undefined ? Math.max(0, Math.min(1, pluginStop.alpha)) : 1,
                      isEndpoint: id === 'start-stop' || id === 'end-stop'
                  };
              }).sort((a, b) => a.position - b.position); // Sort by position

              // Ensure start/end stops exist structurally (add defaults if missing)
              if (!stops.some(s => s.id === 'start-stop')) {
                  console.warn("Start stop missing from plugin data, adding default.");
                  stops.unshift({ id: 'start-stop', position: 0, color: '#ff0000', alpha: 1, isEndpoint: true });
              }
              if (!stops.some(s => s.id === 'end-stop')) {
                  console.warn("End stop missing from plugin data, adding default.");
                  stops.push({ id: 'end-stop', position: 100, color: '#0000ff', alpha: 1, isEndpoint: true });
              }
              stops.sort((a, b) => a.position - b.position); // Re-sort after potential additions

              // Re-render all stops from the new array
              stops.forEach(stop => renderOrUpdateStopElement(stop));

              // Select the first stop after update
              selectStop(stops[0]?.id || null);
              updateGradient(); // Update the gradient display
          }
      }

      // Helper to update a custom select based on received data
      function updateCustomSelectFromData(baseId, value) {
          if (value === undefined || value === null) return; // No value provided
          const hiddenInput = document.getElementById(`${baseId}-value`);
          const wrapper = hiddenInput?.closest('.custom-select-wrapper');
          const selectDiv = wrapper?.querySelector('.custom-select');
          const selectedDisplay = selectDiv?.querySelector('.select-selected'); // Only relevant for dropdowns
          const options = selectDiv?.querySelectorAll('.select-option');

          if (!hiddenInput || !selectDiv || !options) {
               console.warn(`Custom select elements not found for baseId: ${baseId}`);
               return; // Elements not found
          }

          hiddenInput.value = value; // Update hidden input
          let found = false;
          for (let opt of options) {
              opt.classList.remove('same-as-selected'); // Clear previous selection style
              if (opt.getAttribute('data-value') === value) {
                  if (selectedDisplay) { // Update display only if it exists (not for join)
                    selectedDisplay.innerHTML = opt.innerHTML; // Update display HTML (with icon)
                  }
                  opt.classList.add('same-as-selected');
                  // Only move to top for dropdowns (not join)
                  if (selectedDisplay) {
                    opt.parentNode.prepend(opt);
                  }
                  found = true;
                  // Don't break for join, as we need to remove class from all others
                  if (selectedDisplay) break;
              }
          }
          if (!found) { // Handle case where value doesn't match any option
              if (selectedDisplay) selectedDisplay.innerHTML = 'Select...'; // Or display the value itself?
              console.warn(`Value "${value}" not found in options for ${baseId}`);
          }
      }


      // Creates or updates a single stop DOM element based on stop data
      function renderOrUpdateStopElement(stopData) {
          let stopElement = document.getElementById(stopData.id);

          // Create if doesn't exist (and is not an endpoint - endpoints are fixed in HTML)
          if (!stopElement && !stopData.isEndpoint) {
              stopElement = document.createElement('div');
              stopElement.classList.add('color-stop');
              stopElement.id = stopData.id;
              stopElement.innerHTML = `
                  <div class="color-preview"></div>
                  <input type="color">`;
              colorStops.appendChild(stopElement);
              // Add handlers for the newly created element
              setupColorInputHandler(stopData.id);
              const preview = stopElement.querySelector('.color-preview');
              if (preview) {
                  preview.addEventListener('mousedown', (e) => handleStopDragStart(e, stopElement));
              }
          } else if (!stopElement && stopData.isEndpoint) {
              // This case should ideally not happen if HTML is correct
              console.error(`Endpoint stop element missing in DOM: ${stopData.id}`);
              return;
          }

          // Update existing element (color preview and hidden input value)
          if (stopElement) {
              const preview = stopElement.querySelector('.color-preview');
              const input = stopElement.querySelector('input[type="color"]');
              if (preview) preview.style.backgroundColor = stopData.color;
              if (input) input.value = stopData.color;
              // Position is handled separately by positionStops/updateGradient
          }
      }

    </script>
</body>
</html>
